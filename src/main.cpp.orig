#include <iostream>
#include <fstream>
#include <vector>
#include <list>
#include <map>
#include <time.h>
#include <functional>

#include <Snap.h>

#define __DEBUG__ 1
#include <utils.h>

using namespace std;
using namespace TSnap;

#define INF numeric_limits<int>::max()
#define WEIGHTATTR "weight"

void forInput(function<void(const string&)> fn) {
    clock_t begin = clock();

    std::ifstream filelist("input_list.txt");
    string path;
    while (filelist >> path) {
        if (path[0] == '#') {
            continue;
        }
        clock_t t = clock();

        fn(path);

        clock_t now = clock();
        clock_t elapsed_secs = double(now - t) / CLOCKS_PER_SEC;
        if (elapsed_secs < 60) {
            PRINTF("elapsed time=%d sec\n", elapsed_secs);
        } else {
            PRINTF("elapsed time=%d min\n", elapsed_secs / 60);
        }
    }

    clock_t end = clock();
    clock_t elapsed_secs = double(end - begin) / CLOCKS_PER_SEC;
    PRINTF("total time=%d min\n", elapsed_secs / 60);
}

class ICModel {
    const int R;

    // stochastic spread simulation
    size_t diffusion_spread(const MyGraph& G, const vector<NodeI>& seedSet,
                            const bool deterministic = false) {
        list<NodeI> q(seedSet.begin(), seedSet.end());
        map<int, bool> active;
        size_t spread = 0;
        while (!q.empty()) {
            NodeI NI = q.back();
            q.pop_back();
            int out_degree = NI.GetOutDeg();
            //PRINTF("Node %d, out degree=%d\n",NI.GetId(),out_degree);
            while (out_degree-- > 0) { //TODO if=>while
                NodeI out_neighbor = G->GetNI(NI.GetOutNId(out_degree));
                if (active.find(out_neighbor.GetId()) != active.end()) { // already active
                    continue;
                }
                const int in_degree = out_neighbor.GetInDeg();
                //			PRINTF("out neighbor %d has in degree=%d, spread=%d\n",
                //					out_neighbor.GetId(), in_degree, spread);
                if (deterministic || rand() % in_degree == 0) { // true with probability 1/in_degree
                    q.push_front(out_neighbor);
                    active[out_neighbor.GetId()] = true;
                    ++spread;
                }
            }
        }
        return spread;
    }

    // Monte Carlo estimate of expected spread
    float MC_estimate(const MyGraph& G, const vector<NodeI>& seedSet) {
        size_t sum = 0;
        int r = R;
        while (r-- > 0) {
            sum += diffusion_spread(G, seedSet);
        }
        return (float) sum / R;
    }
  public:
    ICModel(const int R, const bool deterministic = false) :
        R(R) {
    }
    tuple<vector<NodeI>, float> seed_selection(MyGraph& G, int k) {
        vector<NodeI> seedSet;
        float spread = 0;
        while (k-- > 0) {
            for (NodeI NI = G->BegNI(); NI != G->EndNI(); NI++) {
                seedSet.push_back(NI);
                float tmp = MC_estimate(G, seedSet);
                if (spread < tmp) {
                    spread = tmp;
                } else {
                    seedSet.pop_back();
                }
            }
        }
        return make_tuple(seedSet, spread);
    }
    // the maximum possible spread using the seedSet
    size_t deterministic_spread(const MyGraph& G,
                                const vector<NodeI>& seedSet) {
        return diffusion_spread(G, seedSet, true);
    }
};

int main() {
    init();
    ofstream resultFile(Reporter::resultDir() + "overall.txt");

    forInput([](const string& path) {
        printf("\nLoading %s\n", path.c_str());
        const TStr pathobj(path.c_str());

        MyGraph G = LoadEdgeList<MyGraph>(pathobj, 0, 1);

        int b=G->GetEdges()-5*G->GetNodes();
        if(b>0) { // sparsify by deleting edges randomly
            while(b-->0) {
                G->DelEdge(G->GetRndEId());
            }
        }
        char title[20];
        sprintf(title,"%d nodes, %d edges\n",G->GetNodes(),G->GetEdges());
        PRINTF("%s\n",title);

        ICModel model(30);
        auto [seeds, spread] = model.seed_selection(G,2);
        const size_t maxSpread = model.deterministic_spread(G,seeds);
        PRINTF("spread=%f, ratio=%f\n", spread, (float)spread/maxSpread);

        PRINTF("drawing the graph in %s\n", path.c_str());
        DrawGViz(G, TGVizLayout::gvlDot,
                 pathobj.GetFPath() + pathobj.GetFMid() + ".png", title,
                 true);

        /*for (auto EI = G->BegEI(); EI < G->EndEI(); EI++) {
         NodeI v = G->GetNI(EI.GetDstNId());
         float p_uv = 1/v.GetInDeg();
         setProb(G,EI,p_uv);
         //			PRINTF("node %d, in degree=%d\n",v.GetId(),v.GetInDeg());
         }*/

//			resultFile.flush();
    });
//	resultFile.close();

    return 0;
}
